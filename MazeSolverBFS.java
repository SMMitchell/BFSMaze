// Programmer: Stephen Mitchell
// Student ID: c3349182
// Last modified: 25 Sept 2022
// Course: COMP2230
// Assignment 1

// This program reads in a file containing data generated by MazeGenerator.java
// and solves the input maze using a Breadth First Search, then uses backtracking
// to  simplify the BSF solution, returning the optimal path to the fiinish point.

import java.util.*;
import java.io.*;
import java.util.Queue;

class MazeSolverBFS
{
	public static void main(String args[]) 		// Run main program
	{
    	
    	int start_node = 0;		// Create and initialise variable for Start Node				
    	int finish_node = 0;	// Create and Initialise variable for Finish Node									
		int height = 0;			// Create and Initialise variable for number of Rows
		int width = 0;			// Create and Initialise variable for number of Columns

		ArrayList<Integer> cell_openness_list = new ArrayList<Integer>();		// Create new ArrayList for all cells openness

		int bothClosed = 0;			// Create and Initialise variable for right and bottom walls
		int rightOnlyOpen = 1;		// Create and Initialise variable for right wall only
		int downOnlyOpen = 2;		// Create and Initialise variable for bottom wall only
		int bothOpen = 3;			// Create and Initialise variable for no walls

    	
		// Read in file and distribute data

    	try
    	{

    		Scanner inputStream = new Scanner (new File (args[0]));   	// Create new Scanner and take input text filename as argument

        	while (inputStream.hasNextLine())					
			{
				String line = inputStream.nextLine();			
				
				String [] mazeData = line.split(":");				// Split and evaluate input file line
				
				String [] dimensions = mazeData[0].split(",");		// Split the first section again to retrieve maze dimensions
				
				height = Integer.parseInt(dimensions[0]);			// Get number of Rows
				
				width = Integer.parseInt(dimensions[1]);			// Get number of Columns
				
				start_node = Integer.parseInt(mazeData[1]);			// Get Starting node number
				
				finish_node = Integer.parseInt(mazeData[2]);		// Get Finish node number
				
				String [] openList = mazeData[3].split("");			// Get openness for each cell
				
				for (int i = 0; i < height*width; i++)				// Iterate through each cell
				{
					cell_openness_list.add(Integer.parseInt(openList[i]));		// Add to cell openness list
				}
			}		
			inputStream.close(); 		// Close input file
        }

    	catch(FileNotFoundException e)		// If file not found
    	{
            System.out.println("Unable to locate file");  // Print Error notice
            return;
        }



        // Populate Maze utilising acquired file data
	
		Node[][] grid = new Node[height][width];		// Populate new grid with dimensions acquired from file
		
		int nodeCount = 0;		// Initiate node count
		int openNumber = 0;		// Initiate variable to get index of cell openness list

		// Add nodes to each cell of the maze

		for(int i = 0; i < height; i++)		// Row by Row 
		{
			for(int j = 0; j < width; j++)	// Column by Column
			{
				nodeCount++;	// Increment Node count
				
				grid[i][j] = new Node(nodeCount, i, j, cell_openness_list.get(openNumber));		// Add new Node with location coordinates and cell openness				
				
				openNumber++;     // Increase openNumber to get next index of cell openness list
				
				// Find the start node within the maze

				if (grid[i][j].getNodeNumber() == start_node)
				{
					grid[i][j].setStartPoint();		// Set Start Point
				}
				
				// Find the finish node within the maze

				if (grid[i][j].getNodeNumber() == finish_node)
				{
					grid[i][j].setFinishPoint();	// Set Finish Point
				}	
			}
		}
		
		// Locate and set Adjacent Nodes

		for(int i = 0; i < height; i++)		// Row by Row
		{
			for(int j = 0; j < width; j++)	// Column by Column
			{	

				// For Nodes not in the first row

				if(i != 0)
				{
					grid[i][j].setAbove(grid[i-1][j]);		// Set Above Neighbour
				}

				// For Nodes not in the first column 
				
				if (j != 0)
				{
					grid[i][j].setLeft(grid[i][j-1]);		// Set Left Neighbour
				}
				
				// For Nodes not in the last row

				if (i != height-1)
				{
					grid[i][j].setBelow(grid[i+1][j]);		// Set Below Neighbour
				}

				// For Nodes not in the first column 
				
				if (j != width-1)
				{
					grid[i][j].setRight(grid[i][j+1]);		// Set Right Neighbour
				}				
			}
		}

		// Solve Maze using BST

		// Create Queues to hold possible path options

		Queue<Node> path = new LinkedList<Node>();		// Create queue to store full BSF path to finish point 
		Queue<Node> solution = new LinkedList<>();		// Create queue to store solution, with no node repitition
		Stack<Node> backTracker = new Stack<>();		// Create a stack to work backwards from finish point (used to find solution)

		
		int totalSteps = 0;				// Create variable to track TOTAL number of steps for BSF solution
		int solutionSteps = 0;			// Create variable to track number of steps in simplified solution

		Node current = new Node();		// Create a temporary Node to track the current Node being used in the BSF search

		// Start Program Timer

		long programStart = System.currentTimeMillis();		// Start the program for the timer

		// Add start node to queue

		for(int i = 0; i < height; i++)			// Row by Row
		{
			for(int j = 0; j < width; j++)		// Column by Column
			{
				if (grid[i][j].getStartPoint() == true)		// Locate start point
				{
					grid[i][j].setSolution();		// Add Start Node to Solutions queue
					
					grid[i][j].setVisited();		// Mark as visited
					
					path.add(grid[i][j]);			// Add to Path Queue
				}
			}
		}

		current = path.remove();	// Remove the start Node from the Queue and set to current

		// Loop through available paths of current Node, removing from and adding to Queue until finish Node has been reached

		while (current.getNodeNumber() != finish_node )
		{

			// Check possible paths for the current Node, by checking which adjacent Nodes are available

			if (current.getAbove() != null)			// If not in top Row
			{
				// Check if already visited, or if there is a wall above 

				if (current.getAbove().getVisited() == false && current.getAbove().getOpenness() != bothClosed && current.getAbove().getOpenness() != rightOnlyOpen)	
				{
					path.add(current.getAbove());				// Add above Node to Queue of possible paths	
					
					current.getAbove().setPrevious(current);	// Above Node is now a child of current Node  
				}				
			}
			
			// Check Below

			if (current.getBelow() != null)			// If not in bottom Row
			{
				// Check if already visited, or if there is a wall above

				if (current.getBelow().getVisited() == false && current.getOpenness() != bothClosed && current.getOpenness() != rightOnlyOpen)	
				{
					path.add(current.getBelow());				// Add below Node to Queue of possible paths
					
					current.getBelow().setPrevious(current);	// Below Node is now a child of current Node 
				}
			}

			// Check Left

			if (current.getLeft() != null)			// If not in first Column
			{
				if(current.getLeft().getVisited() == false && current.getLeft().getOpenness() != bothClosed && current.getLeft().getOpenness() != downOnlyOpen)	
				{
					path.add(current.getLeft());				// Add left Node to Queue of possible paths
					
					current.getLeft().setPrevious(current);		// Left Node is now a child of current Node 	
				}
			}

			// Check Right

			if (current.getRight() != null)			// If not in the Last Column 
			{
				if (current.getRight().getVisited() == false && current.getOpenness() != bothClosed && current.getOpenness() != downOnlyOpen)	
				{
					path.add(current.getRight());				// Add right Node to Queue of possible paths
					
					current.getRight().setPrevious(current);	// Right Node is now a child of current Node 						
				}
			}

			current = path.remove(); 	// Get next Node from the Path Queue

			current.setVisited();		// Set newly acquired Node to visited
		
			totalSteps++;				// Increase the steps of the entire journey
		}

		totalSteps--;		// Decrement by one to account for Start node 

		// Maze is solved. Now back track form the Finish Point, placing each
		// previous Node onto the stack until the Start Point is reached.

		backTracker.push(current);		// Add Finish Point to Stack

		while (current.getNodeNumber() != start_node)		// Loop until the Start Point is reached
		{
			current.setSolution();							// Set current Node as a Node used in the simplified Solution
			
			backTracker.push(current.getPrevious());		// Push the previous Node onto the Stack
			
			current = current.getPrevious();				// Change current Node to previous Node 
		}

		// All Nodes in simplified solution have been acquired

		// Transfer simplified solution to the solutions queue, so Nodes are in the correct order. 

		while (backTracker.size() != 0)			// Loop through stack until empty
		{
			solution.add(backTracker.pop());	// Add to solution queue
			
			solutionSteps++;					// Increment step counter for simplified solution 
		}

		solutionSteps--;	// Decrement by one to account for Start node 

		// Print out Results

		System.out.print("\n(");		// Print first parenthesis	
		
		// Loop through all Nodes in the solution Queue
		
		for (int p = 0; p < solutionSteps + 1; p++)
		{
			if (p == solutionSteps)		// Get last Node
			{	
				System.out.print(solution.remove().getNodeNumber());			// Print final Node with no comma
			}
			else
			{
				System.out.print(solution.remove().getNodeNumber() + ",");		// Return all Nodes (execpt last) in simplified solution Queue
			}
		}
		
		System.out.print(")");		// Print closing parenthesis	

		System.out.print("\n");		// Next Line
		
		System.out.println(solutionSteps);		// Print out simplified solution step count
		
		System.out.println(totalSteps);			// Print out total step count of BFS
		
		// End Program Timer and print resulting time

		System.out.println(System.currentTimeMillis() - programStart);

		

		// If number of Rows and/or columns of Maze doesn't exceed 10
		
		
		// Print Maze with solution

		if (height <= 10 || width <= 10)
		{
			for(int i = 0; i < width*3 + 1; i++)	// Print the top boundary of the Maze 
			{
				System.out.print("-");	
			}
			
			// Drop to First Row

			System.out.print("\n");
			
			for(int i = 0; i < height; i++) // Row by Row 
			{
				System.out.print("|");		// Print Left Boundary of the Maze
				
				for(int j = 0; j < width; j++)		// Column By Column
				{
		
					// If cell needs a wall to the right

					if (grid[i][j].getOpenness() == bothClosed || grid[i][j].getOpenness() == downOnlyOpen) 
					{	
						if (grid[i][j].getStartPoint() == true)		// If cell is the start Point for the Maze
						{
							System.out.print("S |");				// Add an S to the cell
						}
						
						else if (grid[i][j].getFinishPoint() == true)	// If cell is the finish Point for the Maze
						{
							System.out.print("F |");					//Add an F to the cell
						}

						else if (grid[i][j].getSolution() == true && grid[i][j].getStartPoint() == false)	// If cell is part of the simplified solution
						{
							System.out.print("* |");	
						}				
						
						else
						{
							System.out.print("  |");	// Close right side of cell
						}
					}

					// If cell has no wall to the right

					if (grid[i][j].getOpenness() == bothOpen || grid[i][j].getOpenness() == rightOnlyOpen) 
					{	
						if (grid[i][j].getStartPoint() == true)		// If cell is the start Point for the Maze
						{
							System.out.print("S  ");				// Add an S to the cell
						}
						
						else if (grid[i][j].getFinishPoint() == true)	// If cell is the finish Point for the Maze
						{
							System.out.print("F  ");					// Add an F to the cell
						}
						
						else if (grid[i][j].getSolution() == true && grid[i][j].getStartPoint() == false)	// If cell is part of the simplified solution
						{
							System.out.print("*  ");	
						}	
						else 
						{
							System.out.print("   ");	// Open right side of cell
						}
					}		

				}
				
				System.out.print("\n");		// Move to next line
				
				// Print bottom half of the cell
				
				if (i == height - 1)		// For the last Row of the Maze
				{
					for(int g = 0; g < width*3 + 1; g++)
					{
						System.out.print("-");		// Print boundary for the bottome of the Maze
					}
				}
				
				else
				{
					System.out.print("|");
					
					for(int k = 0; k < width; k++)
					{				
						// Check if bottom of the cell is open

						if (grid[i][k].getOpenness() == bothClosed || grid[i][k].getOpenness() == rightOnlyOpen) 
						{
							System.out.print("--|");	// Close bottom of cell
						}
						
						else System.out.print("  |");	// Open Bottom of cell
					}
				    
				    System.out.print("\n");		// Move to next line
				}
			}
		}
    }
}
